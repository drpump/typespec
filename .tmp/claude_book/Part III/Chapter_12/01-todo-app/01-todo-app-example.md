# Todo App API: A Complete REST Example

This chapter presents a complete REST API example for a Todo application built with TypeSpec. This example demonstrates many real-world patterns and best practices for building modern APIs.

## Overview

The Todo App API offers a comprehensive task management system with the following features:

- User management
- Todo item creation, reading, updating, and deletion
- Support for task assignments, status tracking, and labels
- File attachments for tasks
- Authentication via JWT Bearer tokens or API keys

This example showcases how TypeSpec elegantly handles complex API requirements while maintaining clear structure and type safety.

## Core Domain Models

Let's start by examining the core domain models that represent our problem space. These models form the foundation of the API.

### User Model

```typespec
@jsonSchema
model User {
  /** An autogenerated unique id for the user */
  @key
  @visibility(Lifecycle.Read)
  id: safeint;

  /** The user's username */
  @minLength(2)
  @maxLength(50)
  username: string;

  /** The user's email address */
  email: string;

  /**
   * The user's password, provided when creating a user
   * but is otherwise not visible (and hashed by the backend)
   */
  @visibility(Lifecycle.Create)
  password: string;

  /** Whether the user is validated. Never visible to the API. */
  @invisible(Lifecycle) validated: boolean;
}
```

The User model demonstrates several important TypeSpec features:

1. **Property visibility control**: The `@visibility` decorator controls when properties are visible in the API:

   - `id` is only visible when reading (not when creating/updating)
   - `password` is only visible when creating a user (not when reading/updating)
   - `validated` is completely invisible to the API using `@invisible`

2. **Validation constraints**: Using decorators like `@minLength` and `@maxLength` to enforce data validation rules

3. **Documentation**: Each property has JSDoc comments that describe its purpose and behavior

### Todo Item Model

```typespec
@jsonSchema
model TodoItem {
  /** The item's unique id */
  @visibility(Lifecycle.Read) @key id: safeint;

  /** The item's title */
  @maxLength(255)
  title: string;

  /** User that created the todo */
  @visibility(Lifecycle.Read) createdBy: User.id;

  /** User that the todo is assigned to */
  assignedTo?: User.id;

  /** A longer description of the todo item in markdown format */
  description?: string;

  /** The status of the todo item */
  status: "NotStarted" | "InProgress" | "Completed";

  /** When the todo item was created. */
  @visibility(Lifecycle.Read) createdAt: utcDateTime;

  /** When the todo item was last updated */
  @visibility(Lifecycle.Read) updatedAt: utcDateTime;

  /** When the todo item was completed */
  @visibility(Lifecycle.Read) completedAt?: utcDateTime;

  /** Labels attached to the todo item */
  labels?: TodoLabels;
}
```

The TodoItem model highlights:

1. **Relationship modeling**: References to Users through their IDs
2. **Optional properties**: Using the `?` suffix for optional fields
3. **Temporal data**: Using `utcDateTime` for standardized timestamp representation
4. **Enumeration through unions**: Using string literals in a union for status values
5. **Lifecycle control**: Read-only properties for system-generated values

### Todo Labels

```typespec
@jsonSchema
union TodoLabels {
  string,
  string[],
  TodoLabelRecord,
  TodoLabelRecord[],
}

@jsonSchema
model TodoLabelRecord {
  name: string;

  @pattern("^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$")
  color?: string;
}
```

This demonstrates:

1. **Union types**: Allowing different representations of the same concept
2. **Regular expression validation**: The `@pattern` decorator enforcing that colors are valid hex codes
3. **Flexible API design**: Accepting simple strings or structured records for different client needs

### File Attachments

```typespec
@jsonSchema
model TodoAttachment {
  /** The file name of the attachment */
  @maxLength(255)
  filename: string;

  /** The media type of the attachment */
  mediaType: string;

  /** The contents of the file */
  contents: bytes;
}

model FileAttachmentMultipartRequest {
  contents: HttpPart<File>;
}

model ToDoItemMultipartRequest {
  item: HttpPart<TodoItem>;
  attachments?: HttpPart<File>[];
}
```

This shows:

1. **Binary data handling**: Using the `bytes` type for file contents
2. **Multipart requests**: Using `HttpPart<T>` for handling file uploads
3. **Composite requests**: Combining structured data and file uploads in a single request

### Error Handling

```typespec
@jsonSchema
@error
model ApiError {
  /** A machine readable error code */
  code: string;

  /** A human readable message */
  message: string;

  /** Optional additional details */
  details?: Record<unknown>;
}
```

The error model demonstrates:

1. **Standard error pattern**: Using the `@error` decorator to mark models for error responses
2. **Flexible error details**: Using `Record<unknown>` for extensible error information

## API Operations

Now let's look at the operations exposed by the API:

### User Operations

```typespec
@route("/users")
@tag("Users")
interface Users {
  @get list(): User[] | ApiError;

  @get
  @route("/{id}")
  read(@path id: safeint): User | ApiError;

  @post create(@body user: User): User | ApiError;

  @put
  @route("/{id}")
  update(@path id: safeint, @body user: User): User | ApiError;

  @delete
  @route("/{id}")
  delete(@path id: safeint): void | ApiError;
}
```

### Todo Item Operations

```typespec
@route("/todos")
@tag("Todo Items")
interface TodoItems {
  @get list(): TodoItem[] | ApiError;

  @get
  @route("/{id}")
  read(@path id: safeint): TodoItem | ApiError;

  @post create(@body item: TodoItem): TodoItem | ApiError;

  @put
  @route("/{id}")
  update(@path id: safeint, @body item: TodoItem): TodoItem | ApiError;

  @delete
  @route("/{id}")
  delete(@path id: safeint): void | ApiError;

  @route("/{id}/attachments")
  @post
  @header contentType("multipart/form-data")
  addAttachment(
    @path id: safeint,
    @body request: FileAttachmentMultipartRequest
  ): TodoItem | ApiError;
}
```

These operations showcase:

1. **Resource-oriented design**: Grouping operations by resource type
2. **Standard REST patterns**: Using HTTP verbs (GET, POST, PUT, DELETE) for CRUD operations
3. **Path parameters**: Using `@path` to extract IDs from URLs
4. **Multipart handling**: Special handling for file uploads with `multipart/form-data`
5. **Consistent error handling**: Using `ApiError` for all potential error responses

## Authentication

```typespec
@service(#{ title: "Todo App" })
@useAuth(BearerAuth | ApiKeyAuth<ApiKeyLocation.cookie, "session-id">)
@jsonSchema
namespace Todo;
```

The API demonstrates flexible authentication options:

1. **Multiple auth methods**: Supporting both JWT Bearer tokens and API keys
2. **Cookie-based API keys**: Configuring API keys to be sent via cookies
3. **Service-wide auth**: Applying authentication to all operations by default

## Complete Implementation

When combined, these components create a comprehensive REST API for a Todo application. This example illustrates how TypeSpec elegantly handles:

1. **Complex domain modeling**: Rich models with relationships
2. **Access control**: Fine-grained visibility control
3. **Validation**: Constraints at the type level
4. **File uploads**: Binary data handling
5. **Authentication**: Flexible auth options
6. **Documentation**: Built-in documentation through comments

## Generated Outputs

When compiled, this TypeSpec definition generates:

1. **OpenAPI documentation**: For API consumers and documentation portals
2. **JSON Schema**: For validating request and response payloads
3. **Client SDKs**: For consuming the API in various languages

For example, the OpenAPI output would include:

- Schema definitions for User, TodoItem, and other models
- Path definitions for all operations
- Security scheme definitions for authentication
- Examples and descriptions from comments

## Summary

The Todo App example demonstrates how TypeSpec enables you to create a well-designed, fully documented, and type-safe REST API with minimal boilerplate. By leveraging TypeSpec's rich type system and decorators, you can express complex API requirements clearly and concisely.

In the next section, we'll examine another real-world example that highlights different aspects of API design with TypeSpec.
